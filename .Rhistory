outdf <- data.frame(matrix(unlist(char), nrow=1, byrow=T)) #Converts list into usable output format
colnames(outdf) = c("Original Fragment SMILES","MCSS Match SMILES", "Tanimoto Index", "Sigma Value", "Sigma Meta Value", "Sigma Para Value")
print(outdf) #Shows output values
#print(paste("MCSS Match SMILES: ", smiles))
#print(paste("Tanimoto Index: ", Tanimoto))
#print(paste("Sigma Value: ", sigma))
#print(paste("Sigma Meta Value: ", sigma.meta))
#print(paste("Sigma Para Value: ", sigma.para)) #Prints relevant outputs
ChemmineR::plot(MCS[1], regenCoords = TRUE, print = FALSE) #Creates a visualization of output structure
fmcsR::plotMCS(smiles)
?fmcs
smiles <- ChemmineR::sdf2smiles(MCS[1]) #Stores values for best match in SMILES format
ChemmineR::write.SMI(smiles, file = "smiles.smi") #Creates output SMILES file
sigma <- dbGetQuery(lookupdb2, 'SELECT "sigma" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index)) #Searches for sigma values of substructure match
sigma.meta <- dbGetQuery(lookupdb2, 'SELECT "sigma.meta" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
sigma.para <- dbGetQuery(lookupdb2, 'SELECT "sigma.para" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
char <- c(as.character(samplesmi), as.character(smiles), as.character(Tanimoto), as.character(sigma), as.character(sigma.meta), as.character(sigma.para)) #Creates list of output values
outdf <- data.frame(matrix(unlist(char), nrow=1, byrow=T)) #Converts list into usable output format
colnames(outdf) = c("Original Fragment SMILES","MCSS Match SMILES", "Tanimoto Index", "Sigma Value", "Sigma Meta Value", "Sigma Para Value")
print(outdf) #Shows output values
#print(paste("MCSS Match SMILES: ", smiles))
#print(paste("Tanimoto Index: ", Tanimoto))
#print(paste("Sigma Value: ", sigma))
#print(paste("Sigma Meta Value: ", sigma.meta))
#print(paste("Sigma Para Value: ", sigma.para)) #Prints relevant outputs
ChemmineR::plot(MCS[1], regenCoords = TRUE, print = FALSE) #Creates a visualization of output structure
fmcsR::plotMCS(compared)
str(compared)
class(compared)
class(MCS)
fmcsR::plotMCS(MCS)
fmcsR::plotMCS(fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE)
fmcsR::plotMCS(fmcs(batchfull[i], sampleSDF[1], fast = TRUE))
outmcs <- fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE)
fmcsR::plotMCS(outmcs)
class(outmcs)
class(MCS[1])
as(outmcs, MCS, strict=TRUE)
as(outmcs, MCS, strict=FALSE)
as(outmcs, MCS, strict=TRUE, ext)
outmcs <- fmcs(batchfull[i], sampleSDF[1])
fmcsR::plotMCS(outmcs)
fmcsR::plotMCS(outmcs)
outmcs <- fmcs(batchfull[i], sampleSDF[1])
outmcs <- fmcs(batchfull[Index], sampleSDF[1])
fmcsR::plotMCS(outmcs)
sampleSDF[1]
View(sampleSDF[1])
outmcs <- fmcsR::fmcs(batchfull[Index], sampleSDF[1])
fmcsR::plotMCS(outmcs)
outmcs <- fmcsR::fmcs(MCS, sampleSDF[1])
fmcsR::plotMCS(outmcs)
MCS
sampleSDF[1]
viewsmi <- sdf2smiles(MCS)
viewsmi
print(viewsmi)
View(viewsmi)
outmcs2 <- fmcs(batchfull[1], sampleSDF[1])
plotMCS(outmcs2)
outmcs2 <- fmcs(batchfull[35], sampleSDF[1])
plotMCS(outmcs2)
outmcs2 <- fmcs(batchfull[64], sampleSDF[1])
plotMCS(outmcs2)
outmcs2 <- fmcs(batchfull[12], sampleSDF[1])
plotMCS(outmcs2)
outmcs2 <- fmcs(batchfull[10], sampleSDF[1])
plotMCS(outmcs2)
outmcs2 <- fmcs(batchfull[26], sampleSDF[1])
plotMCS(outmcs2)
outmcs2 <- fmcs(batchfull[87], sampleSDF[1])
plotMCS(outmcs2)
library(assertthat)
library(ChemmineOB)
library(ChemmineR)
library(devtools)
library(dplyr)
library(fmcsR)
library(jsonlite)
library(packrat)
library(readr)
library(rjson)
library(RJSONIO)
library(roxygen2)
library(rsconnect)
library(RSQLite)
library(shiny)
library(testthat)
library(tidyr)
library(tools)
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles) #Converts user-input SMILES sample string to SDF format
print(paste("Original Fragment SMILES: ", samplesmiles))
fmcslookupfctn(sampleSDF)
lookupdb <- dbConnect(RSQLite::SQLite(),"")
dbWriteTable(lookupdb, "testlookup", testlookup)
dbListTables(lookupdb)
testlookup2 <- testlookup
testlookup2$ID <- seq.int(nrow(testlookup2))
lookupdb2 <- dbConnect(RSQLite::SQLite(),"")
dbWriteTable(lookupdb2, "testlookup2", testlookup2)
devtools::use_data(lookupdb2, batchfull, internal = TRUE, overwrite = TRUE)
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles) #Converts user-input SMILES sample string to SDF format
print(paste("Original Fragment SMILES: ", samplesmiles))
fmcslookupfctn(sampleSDF)
fmcslookupfctn <- function(sampleSDF) {
MCS = batchfull[1] #Loads comparison library
Tanimoto = 0
Index = 0 #Sets up variables Tanimoto, and Index
samplesmi = ChemmineR::sdf2smiles(sampleSDF)
for(i in 1:300)
{
compared <- fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE) #Compares sample molecule to each molecule in comparison collection
s <- readr::parse_number(compared[4]) #Removes words from output to isolate comparison value
if (s > Tanimoto) #Checks if comparison value is the best match
{
Tanimoto = s
MCS = batchfull[i]
Index = i #Continues checking against the rest of the comparison collection
}
}
if (Tanimoto > 0.7){
smiles <- ChemmineR::sdf2smiles(MCS[1]) #Stores values for best match in SMILES format
ChemmineR::write.SMI(smiles, file = "smiles.smi") #Creates output SMILES file
sigma <- dbGetQuery(lookupdb2, 'SELECT "sigma" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index)) #Searches for sigma values of substructure match
sigma.meta <- dbGetQuery(lookupdb2, 'SELECT "sigma.meta" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
sigma.para <- dbGetQuery(lookupdb2, 'SELECT "sigma.para" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
char <- c(as.character(samplesmi), as.character(smiles), as.character(Tanimoto), as.character(sigma), as.character(sigma.meta), as.character(sigma.para)) #Creates list of output values
outdf <- data.frame(matrix(unlist(char), nrow=1, byrow=T)) #Converts list into usable output format
colnames(outdf) = c("Original Fragment SMILES","MCSS Match SMILES", "Tanimoto Index", "Sigma Value", "Sigma Meta Value", "Sigma Para Value")
print(outdf) #Shows output values
outmcs <- fmcsR::fmcs(MCS, sampleSDF[1])
fmcsR::plotMCS(outmcs)
jsonlite::write_json(outdf, "output-json.json", dataframe = "columns")
}
else {
print("No similar matches were found.")
}
}
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles) #Converts user-input SMILES sample string to SDF format
print(paste("Original Fragment SMILES: ", samplesmiles))
fmcslookupfctn(sampleSDF)
library(assertthat)
library(ChemmineOB)
library(ChemmineR)
library(devtools)
library(dplyr)
library(fmcsR)
library(jsonlite)
library(packrat)
library(readr)
library(rjson)
library(RJSONIO)
library(roxygen2)
library(rsconnect)
library(RSQLite)
library(shiny)
library(testthat)
library(tidyr)
library(tools)
lookupdb <- dbConnect(RSQLite::SQLite(),"")
dbWriteTable(lookupdb, "testlookup", testlookup)
dbListTables(lookupdb)
testlookup2 <- testlookup
testlookup2$ID <- seq.int(nrow(testlookup2))
lookupdb2 <- dbConnect(RSQLite::SQLite(),"")
dbWriteTable(lookupdb2, "testlookup2", testlookup2)
devtools::use_data(lookupdb2, batchfull, internal = TRUE, overwrite = TRUE)
smiles <- ChemmineR::sdf2smiles(MCS[1]) #Stores the best match molecule in SMILES format
ChemmineR::write.SMI(smiles, file = "smiles.smi") #Creates output SMILES file for the match molecule
sigma <- dbGetQuery(lookupdb2, 'SELECT "sigma" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index)) #Retrieves sigma values of match molecule
sigma.meta <- dbGetQuery(lookupdb2, 'SELECT "sigma.meta" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
sigma.para <- dbGetQuery(lookupdb2, 'SELECT "sigma.para" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
char <- c(as.character(samplesmi), as.character(smiles), as.character(Tanimoto), as.character(sigma), as.character(sigma.meta), as.character(sigma.para)) #Creates list of output values
outdf <- data.frame(matrix(unlist(char), nrow=1, byrow=T)) #Converts list into usable output format as a dataframe
colnames(outdf) = c("Original Fragment SMILES","MCSS Match SMILES", "Tanimoto Index", "Sigma Value", "Sigma Meta Value", "Sigma Para Value") #Creates column labels for the dataframe
print(paste("Original Fragment SMILES: ", samplesmi))
print(paste("MCSS Match SMILES: ", smiles))
print(paste("Tanimoto Index: ", Tanimoto))
print(paste("Sigma Value: ", sigma))
print(paste("Sigma Meta Value: ", sigma.meta))
print(paste("Sigma Para Value: ", sigma.para)) #Prints relevant outputs
outmcs <- fmcsR::fmcs(MCS, sampleSDF[1]) #Runs MCS between match molecule and original fragment to get the output information in MCS format for use in the plotMCS visualization function
fmcsR::plotMCS(outmcs) #Visualizes the original fragment and match molecules and highlights the similar substructure
write.csv(outdf, "fmcs-output.csv") #Writes outdf to an output file
?write_json
nomatch = "No similar matches were found."
print(nomatch)
jsonlite::write_json(nomatch, "output-nomatch.json", complex = "string")
nomatch = "No similar matches were found."
print(nomatch)
outnomatch <- c(nomatch, as.character(samplesmi))
jsonlite::write_json(outnomatch, "output-nomatch.json", complex = "string")
nomatch = "No similar matches were found."
origsmi = "Original Fragment SMILES: "
print(nomatch)
outnomatch <- c(nomatch, origsmi, as.character(samplesmi))
jsonlite::write_json(outnomatch, "output-nomatch.json", complex = "string")
nomatch = "No similar matches were found."
origsmi = "Original Fragment SMILES: "
print(nomatch)
outnomatch <- c(nomatch, paste(origsmi, as.character(samplesmi)))
jsonlite::write_json(outnomatch, "output-nomatch.json", complex = "string")
nomatch = "No similar matches were found."
print(nomatch)
outnomatch <- c(nomatch, paste("Original Fragment SMILES:", as.character(samplesmi)))
jsonlite::write_json(outnomatch, "output-nomatch.json", complex = "string")
NoMatch = "No similar matches were found."
print(NoMatch)
OutNoMatch <- c(NoMatch, as.character(samplesmi))
nomatchDF <- data.frame(matrix(unlist(OutNoMatch), nrow=1, byrow = T))
colnames(nomatchDF) = c("Error Message", "Original Fragment SMILES")
jsonlite::write_json(nomatchDF, "output-nomatch.json", dataframe = "columns")
outmcs <- fmcsR::fmcs(MCS, sampleSDF[1])
outmcs
?fmcs
MCS
View(MCS)
MCSsmi <- sdf2smiles(MCS)
MCSsmi
View(MCSsmi)
MCSsmi <- as.character(MCSsmi)
MCSsmi
samsmichar <- as.character(samplesmi)
samsmichar
sampleSDF[1]
sampleSMILE <- sdf2smiles(sampleSDF[1])
sampleSMILE <- as.character(sampleSMILE)
sampleSMILE
sampleSMILE2 <- sdf2smiles(sampleSDF)
sampleSMILE2 <- as.character(sampleSMILE2)
sampleSMILE2
outmcs <- fmcsR::fmcs(MCS, sampleSDF) #Runs MCS between match molecule and original fragment to get the output information in MCS format for use in the plotMCS visualization function
fmcsR::plotMCS(outmcs)
outmcs
?plotMCS
library(assertthat)
library(ChemmineOB)
library(ChemmineR)
library(devtools)
library(dplyr)
library(fmcsR)
library(jsonlite)
library(packrat)
library(readr)
library(rjson)
library(RJSONIO)
library(roxygen2)
library(rsconnect)
library(RSQLite)
library(shiny)
library(testthat)
library(tidyr)
library(tools)
lookupdb <- dbConnect(RSQLite::SQLite(),"")
dbWriteTable(lookupdb, "testlookup", testlookup)
dbListTables(lookupdb)
testlookup2 <- testlookup
testlookup2$ID <- seq.int(nrow(testlookup2))
lookupdb2 <- dbConnect(RSQLite::SQLite(),"")
dbWriteTable(lookupdb2, "testlookup2", testlookup2)
devtools::use_data(lookupdb2, batchfull, internal = TRUE, overwrite = TRUE)
stringfrag <- "NC1=CC=CC=C1*"
stringmatch <- "*C1=CC=CC=C1"
matchfrag <- smiles2sdf(stringmatch)
frag <- smiles2sdf(stringfrag)
outm <- fmcsR::fmcs(matchfrag, frag) #Runs MCS between match molecule and original fragment to get the output information in MCS format for use in the plotMCS visualization function
fmcsR::plotMCS(outm)
MCS[1]
MCS[2]
fmcslookupfctn <- function(sampleSDF) {
MCS = batchfull[1] #Loads comparison library
Tanimoto = 0
Index = 0 #Sets up variables Tanimoto, and Index
samplesmi = ChemmineR::sdf2smiles(sampleSDF) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
for(i in 1:300)
{
compared <- fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE) #Compares sample molecule to each molecule in comparison collection
s <- readr::parse_number(compared[4]) #Removes words from output to isolate comparison value
if (s > Tanimoto) #Checks if comparison value is the best match
{
Tanimoto = s
MCS = batchfull[i]
Index = i #Continues checking against the rest of the comparison collection
}
}
if (Tanimoto > 0.7){
smiles <- ChemmineR::sdf2smiles(MCS[1]) #Stores the best match molecule in SMILES format
ChemmineR::write.SMI(smiles, file = "smiles.smi") #Creates output SMILES file for the match molecule
sigma <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index)) #Retrieves sigma values of match molecule
sigma.meta <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.meta" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
sigma.para <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.para" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
char <- c(as.character(samplesmi), as.character(smiles), as.character(Tanimoto), as.character(sigma), as.character(sigma.meta), as.character(sigma.para)) #Creates list of output values
outdf <- data.frame(matrix(unlist(char), nrow = 1, byrow = T)) #Converts list into usable output format as a dataframe
colnames(outdf) = c("Original Fragment SMILES","MCSS Match SMILES", "Tanimoto Index", "Sigma Value", "Sigma Meta Value", "Sigma Para Value") #Creates column labels for the dataframe
print(outdf) #Shows output values in console
matchSDF <- smiles2sdf(smiles)
outmcs <- fmcsR::fmcs(matchSDF, sampleSDF[1]) #Runs MCS between match molecule and original fragment to get the output information in MCS format for use in the plotMCS visualization function
fmcsR::plotMCS(outmcs) #Visualizes the original fragment and match molecules and highlights the similar substructure
jsonlite::write_json(outdf, "output-json.json", dataframe = "columns") #Writes a JSON containing the output values dataframe for use in CTS
}
else {
NoMatch = "No similar matches were found." #Creates error message
print(NoMatch) #Prints error message to console
OutNoMatch <- c(NoMatch, as.character(samplesmi)) #Starts creating dataframe to put error message into output JSON
nomatchDF <- data.frame(matrix(unlist(OutNoMatch), nrow=1, byrow = T))
colnames(nomatchDF) = c("No Match Found", "Original Fragment SMILES")
jsonlite::write_json(nomatchDF, "output-nomatch.json", dataframe = "columns") #Outputs error message in JSON format
}
}
handleSMIstring <- function(string) {
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles) #Converts user-input SMILES sample string to SDF format
print(paste("Original Fragment SMILES: ", samplesmiles)) #Prints to console the SMILES string for the original sample fragment
fmcslookupfctn(sampleSDF) #Performs MCS matching on sample fragment
}
handleSMIstring(string)
matchSDF
matchSDF <- smiles2sdf(smiles)
outmcs <- fmcsR::fmcs(matchSDF, sampleSDF[1]) #Runs MCS between match molecule and original fragment to get the output information in MCS format for use in the plotMCS visualization function
fmcsR::plotMCS(outmcs) #Visualizes the original fragment and match molecules and highlights the similar substructure
smiles
View(smiles)
as.character(smiles)
smilesCHAR <- as.character(smiles)
smilesCHAR
MCS[1]
?parse_number
smilesPARSED <- parse_guess(smilesCHAR, na = "")
smilesPARSED <- parse_guess(smilesCHAR, na = "MCSS Match Structure")
smilesNAMED <- names(smilesCHAR) = "MCSS Match Structure"
smilesNAMED <- names(smilesCHAR) = c("MCSS Match Structure")
names(smilesCHAR) = "MCSS Match Structure"
smilesCHAR
fmcslookupfctn <- function(sampleSDF) {
MCS = batchfull[1] #Loads comparison library
Tanimoto = 0
Index = 0 #Sets up variables Tanimoto, and Index
samplesmi = ChemmineR::sdf2smiles(sampleSDF) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
for(i in 1:300)
{
compared <- fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE) #Compares sample molecule to each molecule in comparison collection
s <- readr::parse_number(compared[4]) #Removes words from output to isolate comparison value
if (s > Tanimoto) #Checks if comparison value is the best match
{
Tanimoto = s
MCS = batchfull[i]
Index = i #Continues checking against the rest of the comparison collection
}
}
if (Tanimoto > 0.7){
smiles <- ChemmineR::sdf2smiles(MCS[1]) #Stores the best match molecule in SMILES format
smilesCHAR <- as.character(smiles) #
names(smilesCHAR) = "MCSS Match Structure" #
matchSDF <- ChemmineR::smiles2sdf(smilesCHAR) #
fragSMI <- ChemmineR::sdf2smiles(sampleSDF[1]) #
fragCHAR <- as.character(fragSMI) #
names(fragCHAR) = "Original Fragment Structure" #
fragSDF <- ChemmineR::smiles2sdf(fragCHAR)
ChemmineR::write.SMI(smiles, file = "smiles.smi") #Creates output SMILES file for the match molecule
sigma <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index)) #Retrieves sigma values of match molecule
sigma.meta <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.meta" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
sigma.para <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.para" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
char <- c(as.character(samplesmi), as.character(smiles), as.character(Tanimoto), as.character(sigma), as.character(sigma.meta), as.character(sigma.para)) #Creates list of output values
outdf <- data.frame(matrix(unlist(char), nrow = 1, byrow = T)) #Converts list into usable output format as a dataframe
colnames(outdf) = c("Original Fragment SMILES","MCSS Match SMILES", "Tanimoto Index", "Sigma Value", "Sigma Meta Value", "Sigma Para Value") #Creates column labels for the dataframe
print(outdf) #Shows output values in console
outmcs <- fmcsR::fmcs(fragSDF, matchSDF) #Runs MCS between match molecule and original fragment to get the output information in MCS format for use in the plotMCS visualization function
fmcsR::plotMCS(outmcs) #Visualizes the original fragment and match molecules and highlights the similar substructure
jsonlite::write_json(outdf, "output-json.json", dataframe = "columns") #Writes a JSON containing the output values dataframe for use in CTS
}
else {
NoMatch = "No similar matches were found." #Creates error message
print(NoMatch) #Prints error message to console
OutNoMatch <- c(NoMatch, as.character(samplesmi)) #Starts creating dataframe to put error message into output JSON
nomatchDF <- data.frame(matrix(unlist(OutNoMatch), nrow=1, byrow = T))
colnames(nomatchDF) = c("No Match Found", "Original Fragment SMILES")
jsonlite::write_json(nomatchDF, "output-nomatch.json", dataframe = "columns") #Outputs error message in JSON format
}
}
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles) #Converts user-input SMILES sample string to SDF format
print(paste("Original Fragment SMILES: ", samplesmiles)) #Prints to console the SMILES string for the original sample fragment
fmcslookupfctn(sampleSDF) #Performs MCS matching on sample fragment
fmcslookupfctn <- function(sampleSDF) {
MCS = batchfull[1] #Loads comparison library
Tanimoto = 0
Index = 0 #Sets up variables Tanimoto, and Index
samplesmi = ChemmineR::sdf2smiles(sampleSDF) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
for(i in 1:300)
{
compared <- fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE) #Compares sample molecule to each molecule in comparison collection
s <- readr::parse_number(compared[4]) #Removes words from output to isolate comparison value
if (s > Tanimoto) #Checks if comparison value is the best match
{
Tanimoto = s
MCS = batchfull[i]
Index = i #Continues checking against the rest of the comparison collection
}
}
if (Tanimoto > 0.7){
smiles <- ChemmineR::sdf2smiles(MCS[1]) #Stores the best match molecule in SMILES format
smilesCHAR <- as.character(smiles) #
names(smilesCHAR) = "MCSS Match Structure" #
matchSDF <- ChemmineR::smiles2sdf(smilesCHAR) #
fragSMI <- ChemmineR::sdf2smiles(sampleSDF[1]) #
fragCHAR <- as.character(fragSMI) #
names(fragCHAR) = "Original Fragment Structure" #
fragSDF <- ChemmineR::smiles2sdf(fragCHAR) #
outmcs <- fmcsR::fmcs(fragSDF, matchSDF) #Runs MCS between match molecule and original fragment to get the output information in MCS format for use in the plotMCS visualization function
fmcsR::plotMCS(outmcs) #Visualizes the original fragment and match molecules and highlights the similar substructure
ChemmineR::write.SMI(smiles, file = "smiles.smi") #Creates output SMILES file for the match molecule
sigma <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index)) #Retrieves sigma values of match molecule
sigma.meta <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.meta" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
sigma.para <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.para" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
char <- c(as.character(samplesmi), as.character(smiles), as.character(Tanimoto), as.character(sigma), as.character(sigma.meta), as.character(sigma.para)) #Creates list of output values
outdf <- data.frame(matrix(unlist(char), nrow = 1, byrow = T)) #Converts list into usable output format as a dataframe
colnames(outdf) = c("Original Fragment SMILES","MCSS Match SMILES", "Tanimoto Index", "Sigma Value", "Sigma Meta Value", "Sigma Para Value") #Creates column labels for the dataframe
print(outdf) #Shows output values in console
jsonlite::write_json(outdf, "output-json.json", dataframe = "columns") #Writes a JSON containing the output values dataframe for use in CTS
}
else {
NoMatch = "No similar matches were found." #Creates error message
print(NoMatch) #Prints error message to console
OutNoMatch <- c(NoMatch, as.character(samplesmi)) #Starts creating dataframe to put error message into output JSON
nomatchDF <- data.frame(matrix(unlist(OutNoMatch), nrow=1, byrow = T))
colnames(nomatchDF) = c("No Match Found", "Original Fragment SMILES")
jsonlite::write_json(nomatchDF, "output-nomatch.json", dataframe = "columns") #Outputs error message in JSON format
}
}
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles) #Converts user-input SMILES sample string to SDF format
print(paste("Original Fragment SMILES: ", samplesmiles)) #Prints to console the SMILES string for the original sample fragment
fmcslookupfctn(sampleSDF) #Performs MCS matching on sample fragment
fmcsforpckg <- function(sampleSDF) {
MCS = batchfull[1] #Loads comparison library
Tanimoto = 0
Index = 0 #Sets up variables Tanimoto, and Index
samplesmi = ChemmineR::sdf2smiles(sampleSDF) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
for(i in 1:300)
{
compared <- fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE) #Compares sample molecule to each molecule in comparison collection
s <- readr::parse_number(compared[4]) #Removes words from output to isolate comparison value
if (s > Tanimoto) #Checks if comparison value is the best match
{
Tanimoto = s
MCS = batchfull[i]
Index = i #Continues checking against the rest of the comparison collection
}
}
if (Tanimoto > 0.7){
smiles <- ChemmineR::sdf2smiles(MCS[1]) #Stores the best match molecule in SMILES format
smilesCHAR <- as.character(smiles) #
names(smilesCHAR) = "MCSS Match Structure" #
matchSDF <- ChemmineR::smiles2sdf(smilesCHAR) #
fragSMI <- ChemmineR::sdf2smiles(sampleSDF[1]) #
fragCHAR <- as.character(fragSMI) #
names(fragCHAR) = "Original Fragment Structure" #
fragSDF <- ChemmineR::smiles2sdf(fragCHAR) #
outmcs <- fmcsR::fmcs(fragSDF, matchSDF) #Runs MCS between match molecule and original fragment to get the output information in MCS format for use in the plotMCS visualization function
fmcsR::plotMCS(outmcs) #Visualizes the original fragment and match molecules and highlights the similar substructure
ChemmineR::write.SMI(smiles, file = "smiles.smi") #Creates output SMILES file for the match molecule
sigma <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index)) #Retrieves sigma values of match molecule
sigma.meta <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.meta" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
sigma.para <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.para" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
char <- c(as.character(samplesmi), as.character(smiles), as.character(Tanimoto), as.character(sigma), as.character(sigma.meta), as.character(sigma.para)) #Creates list of output values
outdf <- data.frame(matrix(unlist(char), nrow=1, byrow=T)) #Converts list into usable output format as a dataframe
colnames(outdf) = c("Original Fragment SMILES","MCSS Match SMILES", "Tanimoto Index", "Sigma Value", "Sigma Meta Value", "Sigma Para Value") #Creates column labels for the dataframe
print(paste("Original Fragment SMILES: ", samplesmi))
print(paste("MCSS Match SMILES: ", smiles))
print(paste("Tanimoto Index: ", Tanimoto))
print(paste("Sigma Value: ", sigma))
print(paste("Sigma Meta Value: ", sigma.meta))
print(paste("Sigma Para Value: ", sigma.para)) #Prints relevant outputs
write.csv(outdf, "fmcs-output.csv") #Writes outdf to an output file
}
else {
print("No similar matches were found.")
print(paste("Original Fragment SMILES: ", samplesmi))
}
}
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles) #Converts user-input SMILES sample string to SDF format
print(paste("Original Fragment SMILES: ", samplesmiles)) #Prints to console the SMILES string for the original sample fragment
fmcsforpckg(sampleSDF) #Performs MCS matching on sample fragment
library(devtools)
devtools::install_github("sailthru/tidyjson")
devtools::install_github("sailthru/tidyjson")
devtools::install_github("jeremystan/tidyjson")
devtools::install_github("sailthru/tidyjson")
devtools::install_github("sailthru/tidyjson")
library(assertthat)
library(ChemmineOB)
library(ChemmineR)
library(devtools)
library(dplyr)
library(fmcsR)
library(jsonlite)
library(packrat)
library(readr)
library(rjson)
library(RJSONIO)
library(roxygen2)
library(rsconnect)
library(RSQLite)
library(shiny)
library(testthat)
library(tidyr)
library(tools)
library(packrat)

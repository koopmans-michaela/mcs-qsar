char <- c(as.character(samplesmi), as.character(smiles), as.character(Tanimoto), as.character(sigma), as.character(sigma.meta), as.character(sigma.para)) #Creates list of output values
outdf <- data.frame(matrix(unlist(char), nrow = 1, byrow = T)) #Converts list into usable output format as a dataframe
colnames(outdf) = c("Original Fragment SMILES","MCSS Match SMILES", "Tanimoto Match Index", "Sigma Value", "Sigma Meta Value", "Sigma Para Value") #Creates column labels for the dataframe
print(outdf) #Shows output values in console
jsonlite::write_json(outdf, "output-json.json", dataframe = "columns") #Writes a JSON file containing the output values dataframe for use in CTS
}  else {
NoMatch = "No similar matches were found. The closest structure available is given." #Creates error message
closest <- ChemmineR::sdf2smiles(MCS[1]) #Stores the closest MCSS match SMILES
OutNoMatch <- c(NoMatch, as.character(samplesmi), as.character(closest), as.character(Tanimoto)) #Starts creating dataframe to put error message into output JSON
nomatchDF <- data.frame(matrix(unlist(OutNoMatch), nrow=1, byrow = T)) #Creates dataframe
colnames(nomatchDF) = c("No Match Found", "Original Fragment SMILES", "Closest Match SMILES", "Tanimoto Match Index") #Gives dataframe column names
jsonlite::write_json(nomatchDF, "output-nomatch.json", dataframe = "columns") #Outputs error message in JSON format
}
}
handleSMIstring <- function(string) {
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles) #Converts user-input SMILES sample string to SDF format
print(paste("Original Fragment SMILES: ", samplesmiles)) #Prints to console the SMILES string for the original sample fragment
fmcslookupfctn(sampleSDF) #Performs MCS matching on sample fragment
}
string
handleSMIstring(string)
MCS = batchfull[1] #Loads comparison library
Tanimoto = 0
Index = 0 #Sets up variables Tanimoto Match Value and Index Number
samplesmi = ChemmineR::sdf2smiles(sampleSDF) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
for(i in 1:300)
{
compared <- fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE) #Compares sample molecule to each molecule in comparison collection
s <- readr::parse_number(compared[4]) #Removes words from output to isolate comparison value
if (s > Tanimoto) #Checks if comparison value is the best match
{
Tanimoto = s
MCS = batchfull[i]
Index = i #Continues checking against the rest of the comparison collection
}
}
if (Tanimoto > 0.7){
smiles <- ChemmineR::sdf2smiles(MCS[1]) #Stores the best match molecule in SMILES format
smilesCHAR <- as.character(smiles) #Converts match molecule to character string for editing
names(smilesCHAR) = "MCSS Match Structure" #Changes name of match molecule character vector to appropriate label for use in plotMCS
matchSDF <- ChemmineR::smiles2sdf(smilesCHAR) #Converts renamed match molecule vector back to SDF for use in plotMCS
fragSMI <- ChemmineR::sdf2smiles(sampleSDF[1]) #Converts original fragment to SMIset format
fragCHAR <- as.character(fragSMI) #Converts original fragment to character string for editing
names(fragCHAR) = "Original Fragment Structure" #Changes name of original fragment character vector to appropriate label for use in plotMCS
fragSDF <- ChemmineR::smiles2sdf(fragCHAR) #Converts renamed original fragment vector back to SDF for use in plotMCS
outmcs <- fmcsR::fmcs(fragSDF, matchSDF) #Runs MCS between match molecule and original fragment to get the output information in MCS format for use in the plotMCS visualization function
fmcsR::plotMCS(outmcs) #Visualizes the original fragment and match molecules and highlights the similar substructure
ChemmineR::write.SMI(smiles, file = "smiles.smi") #Creates output SMILES file for the match molecule
sigma <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index)) #Retrieves sigma values of match molecule
sigma.meta <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.meta" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
sigma.para <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.para" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
char <- c(as.character(samplesmi), as.character(smiles), as.character(Tanimoto), as.character(sigma), as.character(sigma.meta), as.character(sigma.para)) #Creates list of output values
outdf <- data.frame(matrix(unlist(char), nrow = 1, byrow = T)) #Converts list into usable output format as a dataframe
colnames(outdf) = c("Original Fragment SMILES","MCSS Match SMILES", "Tanimoto Match Index", "Sigma Value", "Sigma Meta Value", "Sigma Para Value") #Creates column labels for the dataframe
print(outdf) #Shows output values in console
jsonlite::write_json(outdf, "output-json.json", dataframe = "columns") #Writes a JSON file containing the output values dataframe for use in CTS
}  else {
NoMatch = "No similar matches were found. The closest structure available is given." #Creates error message
closest <- ChemmineR::sdf2smiles(MCS[1]) #Stores the closest MCSS match SMILES
OutNoMatch <- c(NoMatch, as.character(samplesmi), as.character(closest), as.character(Tanimoto)) #Starts creating dataframe to put error message into output JSON
nomatchDF <- data.frame(matrix(unlist(OutNoMatch), nrow=1, byrow = T)) #Creates dataframe
colnames(nomatchDF) = c("No Match Found", "Original Fragment SMILES", "Closest Match SMILES", "Tanimoto Match Index") #Gives dataframe column names
jsonlite::write_json(nomatchDF, "output-nomatch.json", dataframe = "columns") #Outputs error message in JSON format
}
smiles <- ChemmineR::sdf2smiles(MCS[1]) #Stores the best match molecule in SMILES format
smilesCHAR <- as.character(smiles) #Converts match molecule to character string for editing
names(smilesCHAR) = "MCSS Match Structure" #Changes name of match molecule character vector to appropriate label for use in plotMCS
matchSDF <- ChemmineR::smiles2sdf(smilesCHAR) #Converts renamed match molecule vector back to SDF for use in plotMCS
fragSMI <- ChemmineR::sdf2smiles(sampleSDF[1]) #Converts original fragment to SMIset format
fragCHAR <- as.character(fragSMI) #Converts original fragment to character string for editing
names(fragCHAR) = "Original Fragment Structure" #Changes name of original fragment character vector to appropriate label for use in plotMCS
fragSDF <- ChemmineR::smiles2sdf(fragCHAR) #Converts renamed original fragment vector back to SDF for use in plotMCS
outmcs <- fmcsR::fmcs(fragSDF, matchSDF) #Runs MCS between match molecule and original fragment to get the output information in MCS format for use in the plotMCS visualization function
fmcsR::plotMCS(outmcs)
ChemmineR::write.SMI(smiles, file = "smiles.smi") #Creates output SMILES file for the match molecule
sigma <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index)) #Retrieves sigma values of match molecule
sigma.meta <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.meta" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
sigma.para <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.para" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
char <- c(as.character(samplesmi), as.character(smiles), as.character(Tanimoto), as.character(sigma), as.character(sigma.meta), as.character(sigma.para)) #Creates list of output values
outdf <- data.frame(matrix(unlist(char), nrow = 1, byrow = T)) #Converts list into usable output format as a dataframe
colnames(outdf) = c("Original Fragment SMILES","MCSS Match SMILES", "Tanimoto Match Index", "Sigma Value", "Sigma Meta Value", "Sigma Para Value") #Creates column labels for the dataframe
print(outdf) #Shows output values in console
fmcslookupfctn <- function(sampleSDF) {
MCS = batchfull[1] #Loads comparison library
Tanimoto = 0
Index = 0 #Sets up variables Tanimoto Match Value and Index Number
samplesmi = ChemmineR::sdf2smiles(sampleSDF) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
for(i in 1:300)
{
compared <- fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE) #Compares sample molecule to each molecule in comparison collection
s <- readr::parse_number(compared[4]) #Removes words from output to isolate comparison value
if (s > Tanimoto) #Checks if comparison value is the best match
{
Tanimoto = s
MCS = batchfull[i]
Index = i #Continues checking against the rest of the comparison collection
}
}
if (Tanimoto > 0.7){
smiles <- ChemmineR::sdf2smiles(MCS[1]) #Stores the best match molecule in SMILES format
smilesCHAR <- as.character(smiles) #Converts match molecule to character string for editing
names(smilesCHAR) = "MCSS Match Structure" #Changes name of match molecule character vector to appropriate label for use in plotMCS
matchSDF <- ChemmineR::smiles2sdf(smilesCHAR) #Converts renamed match molecule vector back to SDF for use in plotMCS
fragSMI <- ChemmineR::sdf2smiles(sampleSDF[1]) #Converts original fragment to SMIset format
fragCHAR <- as.character(fragSMI) #Converts original fragment to character string for editing
names(fragCHAR) = "Original Fragment Structure" #Changes name of original fragment character vector to appropriate label for use in plotMCS
fragSDF <- ChemmineR::smiles2sdf(fragCHAR) #Converts renamed original fragment vector back to SDF for use in plotMCS
outmcs <- fmcsR::fmcs(fragSDF, matchSDF) #Runs MCS between match molecule and original fragment to get the output information in MCS format for use in the plotMCS visualization function
fmcsR::plotMCS(outmcs) #Visualizes the original fragment and match molecules and highlights the similar substructure
ChemmineR::write.SMI(smiles, file = "smiles.smi") #Creates output SMILES file for the match molecule
sigma <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index)) #Retrieves sigma values of match molecule
sigma.meta <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.meta" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
sigma.para <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.para" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
char <- c(as.character(samplesmi), as.character(smiles), as.character(Tanimoto), as.character(sigma), as.character(sigma.meta), as.character(sigma.para)) #Creates list of output values
outdf <- data.frame(matrix(unlist(char), nrow = 1, byrow = T)) #Converts list into usable output format as a dataframe
colnames(outdf) = c("Original Fragment SMILES","MCSS Match SMILES", "Tanimoto Match Index", "Sigma Value", "Sigma Meta Value", "Sigma Para Value") #Creates column labels for the dataframe
print(outdf) #Shows output values in console
jsonlite::write_json(outdf, "output-json.json", dataframe = "columns") #Writes a JSON file containing the output values dataframe for use in CTS
}  else {
NoMatch = "No similar matches were found. The closest structure available is given." #Creates error message
closest <- ChemmineR::sdf2smiles(MCS[1]) #Stores the closest MCSS match SMILES
OutNoMatch <- c(NoMatch, as.character(samplesmi), as.character(closest), as.character(Tanimoto)) #Starts creating dataframe to put error message into output JSON
nomatchDF <- data.frame(matrix(unlist(OutNoMatch), nrow=1, byrow = T)) #Creates dataframe
colnames(nomatchDF) = c("No Match Found", "Original Fragment SMILES", "Closest Match SMILES", "Tanimoto Match Index") #Gives dataframe column names
jsonlite::write_json(nomatchDF, "output-nomatch.json", dataframe = "columns") #Outputs error message in JSON format
}
}
handleSMIstring <- function(string) {
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles) #Converts user-input SMILES sample string to SDF format
print(paste("Original Fragment SMILES: ", samplesmiles)) #Prints to console the SMILES string for the original sample fragment
fmcslookupfctn(sampleSDF) #Performs MCS matching on sample fragment
}
string
handleSMIstring(string)
string <- "CC1CC(NC1C)C1=CC=CC=C1*"
handleSMIstring(string)
string <- "NCC1=CC=CC=C1*"
handleSMIstring(string)
string <- "FC(F)(F)S(=O)(=O)\C=C\(C1=CC=CC=C1(*))"
string <- "FC(F)(F)S(=O)(=O)\C=C(C1=CC=CC=C1(*))"
string <- "FC(F)(F)S(=O)(=O)C=CC1=CC=CC=C1*"
string <- "FC(F)(F)S(=O)(=O)\\C=C\\(C1=CC=CC=C1(*))"
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles) #Converts user-input SMILES sample string to SDF format
print(paste("Original Fragment SMILES: ", samplesmiles)) #Prints to console the SMILES string for the original sample fragment
fmcslookupfctn(sampleSDF) #Performs MCS matching on sample fragment
MCS = batchfull[1] #Loads comparison library
Tanimoto = 0
Index = 0 #Sets up variables Tanimoto Match Value and Index Number
samplesmi = ChemmineR::sdf2smiles(sampleSDF) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
for(i in 1:300)
{
compared <- fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE) #Compares sample molecule to each molecule in comparison collection
s <- readr::parse_number(compared[4]) #Removes words from output to isolate comparison value
if (s > Tanimoto) #Checks if comparison value is the best match
{
Tanimoto = s
MCS = batchfull[i]
Index = i #Continues checking against the rest of the comparison collection
}
}
smiles <- ChemmineR::sdf2smiles(MCS[1]) #Stores the best match molecule in SMILES format
smilesCHAR <- as.character(smiles) #Converts match molecule to character string for editing
names(smilesCHAR) = "MCSS Match Structure" #Changes name of match molecule character vector to appropriate label for use in plotMCS
matchSDF <- ChemmineR::smiles2sdf(smilesCHAR) #Converts renamed match molecule vector back to SDF for use in plotMCS
fragSMI <- ChemmineR::sdf2smiles(sampleSDF[1]) #Converts original fragment to SMIset format
fragCHAR <- as.character(fragSMI) #Converts original fragment to character string for editing
names(fragCHAR) = "Original Fragment Structure" #Changes name of original fragment character vector to appropriate label for use in plotMCS
fragSDF <- ChemmineR::smiles2sdf(fragCHAR) #Converts renamed original fragment vector back to SDF for use in plotMCS
outmcs <- fmcsR::fmcs(fragSDF, matchSDF) #Runs MCS between match molecule and original fragment to get the output information in MCS format for use in the plotMCS visualization function
fmcsR::plotMCS(outmcs)
ChemmineR::write.SMI(smiles, file = "smiles.smi") #Creates output SMILES file for the match molecule
sigma <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index)) #Retrieves sigma values of match molecule
sigma.meta <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.meta" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
sigma.para <- RSQLite::dbGetQuery(lookupdb2, 'SELECT "sigma.para" FROM testlookup2 WHERE "ID" == :z', params = list(z = Index))
char <- c(as.character(samplesmi), as.character(smiles), as.character(Tanimoto), as.character(sigma), as.character(sigma.meta), as.character(sigma.para)) #Creates list of output values
outdf <- data.frame(matrix(unlist(char), nrow = 1, byrow = T)) #Converts list into usable output format as a dataframe
colnames(outdf) = c("Original Fragment SMILES","MCSS Match SMILES", "Tanimoto Match Index", "Sigma Value", "Sigma Meta Value", "Sigma Para Value") #Creates column labels for the dataframe
print(outdf) #Shows output values in console
fraglisttest <- read.csv("fraglisttest.csv",h=T)
fraglisttest <- read.csv("fraglisttest.csv",h=T)
View(fraglisttest)
drops <- c("X","X.1")
fraglisttest[ , !(names(fraglisttest) %in% drops)]
View(fraglisttest)
str(fraglisttest)
fraglisttest <- subset(fraglisttest, select = -c(X,X.1))
dout = NULL
for(t in 1:nrow(fragtestlist))
{
string <- fragtestlist[t]
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles)
MCS = batchfull[1] #Loads comparison library
Tanimoto = 0
Index = 0 #Sets up variables Tanimoto Match Value and Index Number
samplesmi = ChemmineR::sdf2smiles(sampleSDF) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
for(i in 1:300)
{
compared <- fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE) #Compares sample molecule to each molecule in comparison collection
s <- readr::parse_number(compared[4]) #Removes words from output to isolate comparison value
if (s > Tanimoto) #Checks if comparison value is the best match
{
Tanimoto = s
MCS = batchfull[i]
Index = i #Continues checking against the rest of the comparison collection
}
}
dout = rbind(dout, data.frame(smi, Tanimoto))
}
dout = NULL
for(t in 1:nrow(fraglisttest))
{
string <- fraglisttest[t]
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles)
MCS = batchfull[1] #Loads comparison library
Tanimoto = 0
Index = 0 #Sets up variables Tanimoto Match Value and Index Number
samplesmi = ChemmineR::sdf2smiles(sampleSDF) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
for(i in 1:300)
{
compared <- fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE) #Compares sample molecule to each molecule in comparison collection
s <- readr::parse_number(compared[4]) #Removes words from output to isolate comparison value
if (s > Tanimoto) #Checks if comparison value is the best match
{
Tanimoto = s
MCS = batchfull[i]
Index = i #Continues checking against the rest of the comparison collection
}
}
dout = rbind(dout, data.frame(smi, Tanimoto))
}
string <- fraglisttest[1]
string
string <- fraglisttest[1,1]
string
string <- as.character(fraglisttest[1,1])
string
string <- as.character(fraglisttest[1,2])
string
string <- as.character(fraglisttest[2,1])
string
dout = NULL
for(t in 1:nrow(fraglisttest))
{
string <- as.character(fraglisttest[t,1])
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles)
MCS = batchfull[1] #Loads comparison library
Tanimoto = 0
Index = 0 #Sets up variables Tanimoto Match Value and Index Number
samplesmi = ChemmineR::sdf2smiles(sampleSDF) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
for(i in 1:300)
{
compared <- fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE) #Compares sample molecule to each molecule in comparison collection
s <- readr::parse_number(compared[4]) #Removes words from output to isolate comparison value
if (s > Tanimoto) #Checks if comparison value is the best match
{
Tanimoto = s
MCS = batchfull[i]
Index = i #Continues checking against the rest of the comparison collection
}
}
dout = rbind(dout, data.frame(smi, Tanimoto))
}
dout = NULL
for(t in 1:nrow(fraglisttest))
{
string <- as.character(fraglisttest[t,1])
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles)
MCS = batchfull[1] #Loads comparison library
Tanimoto = 0
Index = 0 #Sets up variables Tanimoto Match Value and Index Number
samplesmi = ChemmineR::sdf2smiles(sampleSDF) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
for(i in 1:300)
{
compared <- fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE) #Compares sample molecule to each molecule in comparison collection
s <- readr::parse_number(compared[4]) #Removes words from output to isolate comparison value
if (s > Tanimoto) #Checks if comparison value is the best match
{
Tanimoto = s
MCS = batchfull[i]
Index = i #Continues checking against the rest of the comparison collection
}
}
dout = rbind(dout, data.frame(string, Tanimoto))
}
fraglisttest <- fraglisttest[-c(2553:12868)]
View(fraglisttest)
fraglisttest <- fraglisttest[-c(2553:12868),]
dout = NULL
for(t in 1:nrow(fraglisttest))
{
string <- as.character(fraglisttest[t,1])
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles)
MCS = batchfull[1] #Loads comparison library
Tanimoto = 0
Index = 0 #Sets up variables Tanimoto Match Value and Index Number
samplesmi = ChemmineR::sdf2smiles(sampleSDF) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
for(i in 1:300)
{
compared <- fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE) #Compares sample molecule to each molecule in comparison collection
s <- readr::parse_number(compared[4]) #Removes words from output to isolate comparison value
if (s > Tanimoto) #Checks if comparison value is the best match
{
Tanimoto = s
MCS = batchfull[i]
Index = i #Continues checking against the rest of the comparison collection
}
}
dout = rbind(dout, data.frame(string, Tanimoto))
}
fraglisttest <- read.csv("fraglisttest.csv",h=T)
View(fraglisttest)
drops <- c("X","X.1")
fraglisttest[ , !(names(fraglisttest) %in% drops)]
View(fraglisttest)
fraglisttest <- subset(fraglisttest, select = -c(X,X.1))
View(fraglisttest)
fraglisttest <- fraglisttest[-c(2553:12868),]
View(fraglisttest)
fraglisttest <- read.csv("fraglisttest.csv",h=T)
View(fraglisttest)
fraglisttest <- subset(fraglisttest, select = -c(X,X.1))
View(fraglisttest)
newfraglisttest <- fraglisttest[-c(2553:,)]
newfraglisttest <- fraglisttest[-c(2553:12868,)]
newfraglisttest <- fraglisttest[-c(2553:12868),]
View(newfraglisttest)
newfraglisttest <- fraglisttest[-c(2553,2554,2555)]
View(newfraglisttest)
newfraglisttest <- fraglisttest[!apply(data == "", 1, all),]
newfraglisttest <- fraglisttest[c(1:2552,1)]
newfraglisttest <- fraglisttest[c(1,1:2552)]
newfraglisttest <- fraglisttest[1:2552,]
View(newfraglisttest)
dout = NULL
for(t in 1:nrow(fraglisttest))
{
string <- as.character(fraglisttest[t,1])
samplesmiles <- string #Stores SMILES string input
sampleSDF <- ChemmineR::smiles2sdf(samplesmiles)
MCS = batchfull[1] #Loads comparison library
Tanimoto = 0
Index = 0 #Sets up variables Tanimoto Match Value and Index Number
samplesmi = ChemmineR::sdf2smiles(sampleSDF) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
for(i in 1:300)
{
compared <- fmcsR::fmcs(batchfull[i], sampleSDF[1], fast = TRUE) #Compares sample molecule to each molecule in comparison collection
s <- readr::parse_number(compared[4]) #Removes words from output to isolate comparison value
if (s > Tanimoto) #Checks if comparison value is the best match
{
Tanimoto = s
MCS = batchfull[i]
Index = i #Continues checking against the rest of the comparison collection
}
}
dout = rbind(dout, data.frame(string, Tanimoto))
}
View(dout)
write.csv(dout, 'dout.csv')
library(assertthat)
library(ChemmineOB)
library(ChemmineR)
library(devtools)
library(dplyr)
library(fmcsR)
library(jsonlite)
library(packrat)
library(readr)
library(rjson)
library(RJSONIO)
library(roxygen2)
library(rsconnect)
library(RSQLite)
library(shiny)
library(testthat)
library(tidyr)
library(tools)
str(samplesmiles)
stringlist <- read.csv("SMILESforconvert.csv")
View(stringlist)
samplesmileslist <- stringlist #Stores SMILES string inputs
sampleSDFlist <- ChemmineR::smiles2sdf(samplesmileslist) #Converts to SDF list
convertedSMILES <- ChemmineR::sdf2smiles(sampleSDFlist) #Converts back to SMILES
write.csv(convertedSMILES, file = "converted SMILES.csv")
SDFtry <- convertFormat("SMI","SDF",stringlist)
stringlist <- read.csv("SMILESforconvert.csv", h=F)
View(stringlist)
convertFormatFile("SMI","SDF","sdf1output.smi","sdf1output.sdf")
convertFormatFile("SDF","SMI","sdf1output.sdf","sdf1converted.smi")
convertFormatFile("SMIset","SDFset","sdf1output.smiset","sdf1output.sdfset")
convertFormatFile("SDFset","SMIest","sdf1output.sdfset","sdf1converted.smiset")
SMIset1=read.SMIset("smiles1converted.smiles")
SMIset1=read.SMIset("smiles1converted.smiles")
View(SMIset1)
sdfset1 <- smiles2sdf(SMIset1)
sdfset1
sdfset1 <- ChemmineR::smiles2sdf(SMIset1)
convertFormatFile("SMI","SDF","smiles1converted.smiles","sdf1converted.sdf")
sdftry <- convertFormat("SMI","SDF","F*")
sdftry
SDFset1 <- smiles2sd(SMIset1)
SDFset1 <- smiles2sdf(SMIset1)
library(assertthat)
library(ChemmineOB)
library(ChemmineR)
library(devtools)
library(dplyr)
library(fmcsR)
library(jsonlite)
library(packrat)
library(readr)
library(rjson)
library(RJSONIO)
library(roxygen2)
library(rsconnect)
library(RSQLite)
library(shiny)
library(testthat)
library(tidyr)
library(tools)
smileslist <- read.csv("smiles-regular.csv",h=F)
dout2 = NULL #Create empty dataframe
for(t in 1:nrow(smileslist)) #iterate through all frags in list
{
string2 <- as.character(smileslist[t,1]) #for each iteration, take the SMILES string as characters and store it as a character string
stringtosmiles <- string2 #Stores "string2" as a SMILES file
smilestosdf <- ChemmineR::smiles2sdf(stringtosmiles) #Converts SMILES file to SDF file
sdftosmiles = ChemmineR::sdf2smiles(smilestosdf) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
dout2 = rbind(dout2, data.frame(as.character(sdftosmiles))) #Creates output dataframe of the converted SMILES string
}
write.csv(dout2, file = "convertedSMILES-regular.csv")
smileslist <- read.csv("smiles-regular.csv",h=F)
dout2 = NULL #Create empty dataframe
for(t in 1:nrow(smileslist)) #iterate through all frags in list
{
string2 <- as.character(smileslist[t,1]) #for each iteration, take the SMILES string as characters and store it as a character string
stringtosmiles <- string2 #Stores "string2" as a SMILES file
smilestosdf <- ChemmineR::smiles2sdf(stringtosmiles) #Converts SMILES file to SDF file
sdftosmiles = ChemmineR::sdf2smiles(smilestosdf) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
dout2 = rbind(dout2, data.frame(as.character(sdftosmiles))) #Creates output dataframe of the converted SMILES string
}
View(smileslist)
string2
stringtosmiles
smilestosdf
sdftosmiles
as.character(sdftosmiles)
names(sdftosmiles) = "Converted SMILES"
name(sdftosmiles) = "Converted SMILES"
smilescharacter <- as.character(sdftosmiles)
names(smilescharacter) = "Converted SMILES"
smilescharacter
smileslist <- read.csv("smiles-regular.csv",h=F)
dout2 = NULL #Create empty dataframe
for(t in 1:nrow(smileslist)) #iterate through all frags in list
{
string2 <- as.character(smileslist[t,1]) #for each iteration, take the SMILES string as characters and store it as a character string
stringtosmiles <- string2 #Stores "string2" as a SMILES file
smilestosdf <- ChemmineR::smiles2sdf(stringtosmiles) #Converts SMILES file to SDF file
sdftosmiles <- ChemmineR::sdf2smiles(smilestosdf) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
smilescharacter <- as.character(sdftosmiles)
names(smilescharacter) = "Converted SMILES"
dout2 = rbind(dout2, data.frame(as.character(smilescharacter))) #Creates output dataframe of the converted SMILES string
}
write.csv(dout2, file = "convertedSMILES-regular.csv")
View(dout2)
smileslist <- read.csv("smiles-meta.csv",h=F)
dout2 = NULL #Create empty dataframe
for(t in 1:nrow(smileslist)) #iterate through all frags in list
{
string2 <- as.character(smileslist[t,1]) #for each iteration, take the SMILES string as characters and store it as a character string
stringtosmiles <- string2 #Stores "string2" as a SMILES file
smilestosdf <- ChemmineR::smiles2sdf(stringtosmiles) #Converts SMILES file to SDF file
sdftosmiles <- ChemmineR::sdf2smiles(smilestosdf) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
smilescharacter <- as.character(sdftosmiles)
names(smilescharacter) = "Converted SMILES"
dout2 = rbind(dout2, data.frame(as.character(smilescharacter))) #Creates output dataframe of the converted SMILES string
}
write.csv(dout2, file = "convertedSMILES-meta.csv")
smileslist <- read.csv("smiles-para.csv",h=F)
dout2 = NULL #Create empty dataframe
for(t in 1:nrow(smileslist)) #iterate through all frags in list
{
string2 <- as.character(smileslist[t,1]) #for each iteration, take the SMILES string as characters and store it as a character string
stringtosmiles <- string2 #Stores "string2" as a SMILES file
smilestosdf <- ChemmineR::smiles2sdf(stringtosmiles) #Converts SMILES file to SDF file
sdftosmiles <- ChemmineR::sdf2smiles(smilestosdf) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
smilescharacter <- as.character(sdftosmiles)
names(smilescharacter) = "Converted SMILES"
dout2 = rbind(dout2, data.frame(as.character(smilescharacter))) #Creates output dataframe of the converted SMILES string
}
write.csv(dout2, file = "convertedSMILES-para.csv")
smileslist <- read.csv("smiles-ortho.csv",h=F)
dout2 = NULL #Create empty dataframe
for(t in 1:nrow(smileslist)) #iterate through all frags in list
{
string2 <- as.character(smileslist[t,1]) #for each iteration, take the SMILES string as characters and store it as a character string
stringtosmiles <- string2 #Stores "string2" as a SMILES file
smilestosdf <- ChemmineR::smiles2sdf(stringtosmiles) #Converts SMILES file to SDF file
sdftosmiles <- ChemmineR::sdf2smiles(smilestosdf) #Converts sample fragment from SDF to SMILES to be used in the output dataframe
smilescharacter <- as.character(sdftosmiles)
names(smilescharacter) = "Converted SMILES"
dout2 = rbind(dout2, data.frame(as.character(smilescharacter))) #Creates output dataframe of the converted SMILES string
}
write.csv(dout2, file = "convertedSMILES-ortho.csv")
